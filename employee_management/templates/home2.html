document.addEventListener('DOMContentLoaded', function() {
    const breakToggle = document.getElementById('breakToggle');
    const breakStatus = document.getElementById('breakStatus');
    const csrfToken = "{{ csrf_token }}";  // Get CSRF token for request

    // Timer management
    let timers = {}; // Store active timers

    function stopAllTimers() {
        // Stop all running timers and update the backend with the accumulated time
        Object.keys(timers).forEach(ticketId => {
            clearInterval(timers[ticketId].interval); // Stop the timer interval
            const timeSpent = (Date.now() - timers[ticketId].startTime) / 1000 + timers[ticketId].accumulatedTime;

            // Update the time on the server
            fetch('/update_time_spent/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    ticket_id: ticketId,
                    time_spent: timeSpent
                })
            }).then(response => response.json()).then(data => {
                if (data.status !== 'success') {
                    console.error('Failed to update time spent:', data.message);
                }
            });

            // Reset the timer display and save the stopped state
            document.getElementById('timer-' + ticketId).textContent = formatTime(0);
            timers[ticketId] = { accumulatedTime: timeSpent, running: false }; // Update local storage or state
        });

        // Clear all timer intervals
        timers = {};
    }

    // Listen for changes to the break toggle and update the status via AJAX
    breakToggle.addEventListener('change', function() {
        if (this.checked) {
            // If break is toggled on, stop all active timers
            stopAllTimers();
        }

        // Toggle the break status via an AJAX request
        fetch("{% url 'toggle_break_status' %}", {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({}),
        })
        .then(() => {
            // Reload the page after toggling the break to update ticket visibility
            window.location.reload();
        })
        .catch(error => {
            console.error('Error:', error);
        });
    });
});


@login_required
def toggle_break_status(request):
    user_profile = request.user.employeeprofile
    user_profile.is_on_break = not user_profile.is_on_break  # Toggle break status
    user_profile.save()

    # Update the session activity for the current session
    today = timezone.now().date()
    try:
        current_session = SessionActivity.objects.filter(user=request.user, date=today, logout_time=None).latest('login_time')

        if user_profile.is_on_break:
            # If the user is now on break, stop all active tickets and record their time
            active_tickets = Ticket.objects.filter(assigned_to=request.user, is_active=True)
            for ticket in active_tickets:
                ticket.pause_work()  # Pause the timer and calculate time spent
                ticket.save()

            # Record the break start time
            current_session.break_start_time = timezone.now()
            current_session.save()
        else:
            # Ensure break_start_time is not None before calculating the duration
            if current_session.break_start_time:
                break_duration = timezone.now() - current_session.break_start_time
                current_session.break_duration += break_duration
                current_session.work_time = current_session.calculate_work_time()
            current_session.save()

    except SessionActivity.DoesNotExist:
        pass  # No active session found, nothing to update

    return redirect('home')
